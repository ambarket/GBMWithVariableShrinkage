package parameterTuning.plotting;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.TreeSet;
import java.util.concurrent.Callable;

import dataset.Attribute;
import dataset.Dataset;
import gbm.GbmParameters;
import parameterTuning.ParameterTuningParameters;
import utilities.CommandLineExecutor;
import utilities.MaxAndMin;
import utilities.SimpleHostLock;
import utilities.StopWatch;
import utilities.SumCountAverage;

public class PredictionGraphGenerator implements Callable<Void> {
	Dataset dataset;
	GbmParameters parameters;
	String runDataFullDirectory;
	ParameterTuningParameters tuningParameters;
	int submissionNumber;
	StopWatch globalTimer;
	String[][] predictorNamesSets;
	
	int numberOfExamples;
	
	int[] trainingDataCount;
	double[] trainingDataPrediction;
	double[] trainingDataResidual;
	double[] trainingDataAvgLearningRate;
	
	int[] testDataCount;
	double[] testDataPrediction;
	double[] testDataResidual;
	double[] testDataAvgLearningRate;
	
	double[] targetResponses;
	
	String allGraphsDirectory;
	public PredictionGraphGenerator(Dataset dataset, GbmParameters parameters, String runDataFullDirectory, ParameterTuningParameters tuningParameters, int submissionNumber, StopWatch globalTimer, String[][] predictorNamesSets) {
		
		this.dataset = dataset;
		this.parameters = parameters;
		this.runDataFullDirectory = runDataFullDirectory;
		this.tuningParameters = tuningParameters;
		this.submissionNumber = submissionNumber;
		this.globalTimer = globalTimer;
		

		
		numberOfExamples = dataset.getNumberOfTrainingExamples();
		
		trainingDataCount = new int[numberOfExamples];
		trainingDataPrediction = new double[numberOfExamples];
		trainingDataResidual = new double[numberOfExamples];
		trainingDataAvgLearningRate = new double[numberOfExamples];
		
		testDataCount = new int[numberOfExamples];
		testDataPrediction = new double[numberOfExamples];
		testDataResidual = new double[numberOfExamples];
		testDataAvgLearningRate = new double[numberOfExamples];
		
		targetResponses = new double[numberOfExamples];
		
		this.predictorNamesSets = predictorNamesSets;
		
		this.allGraphsDirectory = runDataFullDirectory + parameters.getRunDataSubDirectory(tuningParameters.runFileType) + "PerExampleRunDataGraphs/";
	}
	
	public Void call() {
		StopWatch timer = new StopWatch().start();
		String locksDir = tuningParameters.locksDirectory + dataset.parameters.minimalName + "/PerExampleRunDataGraphs/" + parameters.getRunDataSubDirectory(tuningParameters.runFileType);
		new File(locksDir).mkdirs();
		if (SimpleHostLock.checkDoneLock(locksDir + "predictionGraphs--doneLock.txt")) {
			printSuccessMessage("Graphs already generated by another host or previous run", timer);
			return null;
		}
		if (!SimpleHostLock.checkAndClaimHostLock(locksDir + "predictionGraphs--hostLock.txt")) {
			System.out.println(StopWatch.getDateTimeStamp() + String.format("[%s] Another host claimed prediction graphs for %s (%d out of %d) in %s. Have been running for %s total.", 
					dataset.parameters.minimalName,parameters.getRunDataSubDirectory(tuningParameters.runFileType), submissionNumber, tuningParameters.totalNumberOfTests, timer.getTimeInMostAppropriateUnit(), globalTimer.getTimeInMostAppropriateUnit()));
			return null;
		}
		
		String runDataFilePath = runDataFullDirectory + parameters.getRunDataSubDirectory(tuningParameters.runFileType) + parameters.getFileNamePrefix(tuningParameters.runFileType)  + "--averagePerExampleRunData.txt";
		try {
			BufferedReader br = new BufferedReader(new FileReader(runDataFilePath));
			br.readLine(); // skip header
			// read in error data 
			String line = null;
			int i = 0;
			while ((line = br.readLine()) != null) {
				String[] components = line.split("\t");

				if (Integer.parseInt(components[0]) != i) {
					throw new IllegalStateException();
				}
				
				targetResponses[i] = Double.parseDouble(components[1]);
				trainingDataCount[i] = Integer.parseInt(components[2]);
				trainingDataPrediction[i] = Double.parseDouble(components[3]);
				trainingDataResidual[i] = Double.parseDouble(components[4]);
				trainingDataAvgLearningRate[i] = Double.parseDouble(components[5]);
				testDataCount[i] = Integer.parseInt(components[6]);
				testDataPrediction[i] = Double.parseDouble(components[7]);
				testDataResidual[i] = Double.parseDouble(components[8]);
				testDataAvgLearningRate[i] = Double.parseDouble(components[9]);

				i++;
			}
			br.close();
		} catch (IOException e) {
			System.err.println(StopWatch.getDateTimeStamp());
			e.printStackTrace();
			printFailureMessage("Reading of per example run data failed, not writing done lock!", timer);
			return null;
		}
		

		boolean success = false;
		Graph exampleNumGraph = new Graph(GraphType.ExampleNumberToPredictionGraph);
		success = exampleNumGraph.generateMathematicaScriptAndLatexCode();
		if (!success) {
			printFailureMessage("Generation of exampleNum graph failed, not writing done lock!", timer); 
			return null;
		} 
		success = CommandLineExecutor.executeMathematicaScript(exampleNumGraph.graphsDirectory, exampleNumGraph.mathematicaScriptFileName);
		
		if (!success) {
			printFailureMessage("Execution of exampleNum graph mathematica script failed, not writing done lock!", timer); 
			return null;
		}
		
		for (String[] names : predictorNamesSets) {
			Graph predictorGraph = new Graph(GraphType.PredictorsToPredictionGraph, names);
			success = predictorGraph.generateMathematicaScriptAndLatexCode();
			if (!success) {
				printFailureMessage("Generation of predictor graph failed, not writing done lock!", timer); 
				return null;
			} 
			success = CommandLineExecutor.executeMathematicaScript(predictorGraph.graphsDirectory, predictorGraph.mathematicaScriptFileName);
			
			if (!success) {
				printFailureMessage("Execution of predictor graph mathematica script failed, not writing done lock!", timer); 
				return null;
			}
		}
		
		printSuccessMessage("Per Example graphs successfully generated and executed by this run.", timer);
		SimpleHostLock.writeDoneLock(locksDir + "predictionGraphs--doneLock.txt");
		return null;
		
	}
	
	private void printFailureMessage(String reason, StopWatch timer) {
		System.out.println(StopWatch.getDateTimeStamp() + String.format("[%s] " + reason + "\n\t Failed to generate per example graphs for %s (%d out of %d) in %s. Have been running for %s total.\n\t\t%s", 
				dataset.parameters.minimalName,parameters.getRunDataSubDirectory(tuningParameters.runFileType), submissionNumber, tuningParameters.totalNumberOfTests, timer.getTimeInMostAppropriateUnit(), globalTimer.getTimeInMostAppropriateUnit(), allGraphsDirectory));
	}
	
	private void printSuccessMessage(String reason, StopWatch timer) {
		System.out.println(StopWatch.getDateTimeStamp() + String.format("[%s] " + reason + "\n\t Successfully finished generating and executing per example graphs for %s (%d out of %d) in %s. Have been running for %s total.\n\t\t%s", 
				dataset.parameters.minimalName,parameters.getRunDataSubDirectory(tuningParameters.runFileType), submissionNumber, tuningParameters.totalNumberOfTests, timer.getTimeInMostAppropriateUnit(), globalTimer.getTimeInMostAppropriateUnit(), allGraphsDirectory));
	}
	
	public enum GraphType {ExampleNumberToPredictionGraph, PredictorsToPredictionGraph};
	private class Graph {
		
		GraphType graphType;
		
		String responseCurveBaseName = "targetResponses";
		String trainingPredictionCurveBaseName = "TrainingPredictions";
		String testPredictionCurveBaseName = "TestPredictions";
		
		String trainingResidualCurveBaseName = "TrainingResiduals";
		String testResidualCurveBaseName = "TestResiduals";
		
		String mathematicaScriptFileName = "MathScript.m";
		String latexCodeFileName = "latexCode.txt";
		
		
		String graphsDirectory;
		
		int[] predictorIndices;
		
		String predictorNamesSubDirectory;
		
		String axesLabels;
		
		public Graph(GraphType graphType) {
			this.graphType = graphType;
			
			if (graphType == GraphType.ExampleNumberToPredictionGraph) {
				graphsDirectory = allGraphsDirectory + "ExampleNumberToPredictionGraphs/";
			} else {
				throw new IllegalArgumentException();
			}
			
			axesLabels = ", AxesLabel->{\"Example Number\", \"" + dataset.getResponseName() + "\"}";
		}
		
		public Graph(GraphType graphType, String[] predictorNames) {
			this.graphType = graphType;
			
			// Sort predictor names to guarantee deterministic directory structure
			Arrays.sort(predictorNames);
			if (predictorNames.length == 1) {
				predictorNamesSubDirectory = predictorNames[0];
				axesLabels = ", AxesLabel->{\"" + predictorNames[0] + "\", \"" + dataset.getResponseName() + "\"}";
			} else if (predictorNames.length == 2) {
				predictorNamesSubDirectory = predictorNames[0] + "vs" + predictorNames[1];
				axesLabels = ", AxesLabel->{\"" + predictorNames[0] + "\", \"" + predictorNames[1] + "\", \"" + dataset.getResponseName() + "\"}";
			} else {
				throw new IllegalArgumentException("Only 2D and 3D graphs are supported");
			}
			
			if (graphType == GraphType.PredictorsToPredictionGraph) {
				graphsDirectory = allGraphsDirectory + predictorNamesSubDirectory + "/";
			} else {
				throw new IllegalArgumentException();
			}
			


			String[] dsPredictorNames = dataset.getPredictorNames();
			predictorIndices = new int[predictorNames.length];
		
			for (int i = 0; i < predictorNames.length; i++) {
				for (int j = 0; j < dsPredictorNames.length; j++) {
					if (dsPredictorNames[j].equals(predictorNames[i])) {
						predictorIndices[i] = j;
						break;
					}
				}
			}
		}
		
		public boolean generateMathematicaScriptAndLatexCode() {
			new File(graphsDirectory).mkdirs();
			try {
				BufferedWriter mathScript = new BufferedWriter(new PrintWriter(graphsDirectory + mathematicaScriptFileName));
				BufferedWriter latexCode = new BufferedWriter(new PrintWriter(graphsDirectory + latexCodeFileName));
		
				MaxAndMin[] plotRanges = printDataLists(mathScript);
				printPlotCode(mathScript, plotRanges);
				printSaveToFileCode(mathScript);
				mathScript.flush();
				mathScript.close();
				
				printLatexCode(latexCode);
				latexCode.flush();
				latexCode.close();
				
				return true;
			} catch (IOException e) {
				System.err.println(StopWatch.getDateTimeStamp());
				e.printStackTrace();
				return false;
			}
		}
		
		private MaxAndMin[] printDataLists(BufferedWriter bw) throws IOException {
			TreeSet<Point> points = null;
			if (graphType == GraphType.ExampleNumberToPredictionGraph) {
				points = getExampleNumberPredictionGraphPoints();
			} else if (graphType == GraphType.PredictorsToPredictionGraph) {
				points = getPairWisePredictorGraphPoints();
			}
			
			StringBuilder responseCurve = new StringBuilder();
			StringBuilder trainingPredictionCurve = new StringBuilder();
			StringBuilder testPredictionCurve = new StringBuilder();
			StringBuilder trainingResidualCurve = new StringBuilder();
			StringBuilder testResidualCurve = new StringBuilder();
			MaxAndMin[] plotRanges = new MaxAndMin[] {new MaxAndMin(), new MaxAndMin()}; // 0 - predication/response graph 1 - residuals graph
			for (Point p : points) {
				if (responseCurve.length() != 0) {
					responseCurve.append(", ");
				} else {
					responseCurve.append(responseCurveBaseName + "Data = {");
				}
				responseCurve.append(p.getResponseCurveEntry());
				plotRanges[0].updateMaxAndMinIfNecessary(p.getResponseValue());
				
				String trainingDataEntry = p.getTrainingDataPredictionCurveEntry();
				String testDataEntry = p.getTestDataPredictionCurveEntry();
				String trainingResidualEntry = p.getTrainingDataResidualCurveEntry();
				String testResidualEntry = p.getTestDataResidualCurveEntry();
				// Only graph training/test data entry if at least one of the averaged run data files used an examples
				//	as training and test data respectively.
				if (trainingDataEntry != null) {
					if (trainingPredictionCurve.length() != 0) {
						trainingPredictionCurve.append(", ");
					}  else {
						trainingPredictionCurve.append(trainingPredictionCurveBaseName + "Data = {");
					}
					trainingPredictionCurve.append(trainingDataEntry);
					plotRanges[0].updateMaxAndMinIfNecessary(p.getTrainingDataPredictionValue());
				}
				if (testDataEntry != null) {
					if (testPredictionCurve.length() != 0) {
						testPredictionCurve.append(", ");
					}  else {
						testPredictionCurve.append(testPredictionCurveBaseName + "Data = {");
					}
					testPredictionCurve.append(testDataEntry);
					plotRanges[0].updateMaxAndMinIfNecessary(p.getTestDataPredictionValue());
				}
				if (trainingResidualEntry != null) {
					if (trainingResidualCurve.length() != 0) {
						trainingResidualCurve.append(", ");
					}  else {
						trainingResidualCurve.append(trainingResidualCurveBaseName + "Data = {");
					}
					trainingResidualCurve.append(trainingResidualEntry);
					plotRanges[1].updateMaxAndMinIfNecessary(p.getTrainingDataResidualValue());
				}
				if (testResidualEntry != null) {
					if (testResidualCurve.length() != 0) {
						testResidualCurve.append(", ");
					}  else {
						testResidualCurve.append(testResidualCurveBaseName + "Data = {");
					}
					testResidualCurve.append(testResidualEntry);
					plotRanges[1].updateMaxAndMinIfNecessary(p.getTestDataResidualValue());
				}
			}
			responseCurve.append("}\n\n");
			trainingPredictionCurve.append("}\n\n");
			testPredictionCurve.append("}\n\n");
			trainingResidualCurve.append("}\n\n");
			testResidualCurve.append("}\n\n");
			
			bw.write(responseCurve.toString());
			bw.write(trainingPredictionCurve.toString());
			bw.write(testPredictionCurve.toString());
			bw.write(trainingResidualCurve.toString());
			bw.write(testResidualCurve.toString());
			return plotRanges;
		}
		
		private void printPlotCode(BufferedWriter bw, MaxAndMin[] plotRanges) throws IOException {
			String plotCommand = null;
			if (graphType == GraphType.ExampleNumberToPredictionGraph || predictorIndices.length == 1) {
				plotCommand = "ListPlot";
			} else {
				plotCommand = "ListPlot3D";
			}
			
			String predictionsPlotRange = "{" + plotRanges[0].min + ", " + plotRanges[0].max + "}";
			String residualPlotRange = "{" + plotRanges[1].min + ", " + plotRanges[1].max + "}";
			String automaticPlotRange = "Automatic";
			String twoDimPredictionsPlotRange = ", PlotRange -> {" + automaticPlotRange + ", " + predictionsPlotRange + "}";
			String twoDimResidualsPlotRange = ", PlotRange -> {" + automaticPlotRange + ", " + residualPlotRange + "}";
			String threeDimPlotRange = ", PlotRange -> {" + automaticPlotRange + ", " + automaticPlotRange + ", " + predictionsPlotRange + "}";
			bw.write(responseCurveBaseName + "Plot = " + plotCommand + "[{" + responseCurveBaseName + "Data}"
					+ ", PlotLegends -> {\"Target\"}"
					+ ((graphType == GraphType.ExampleNumberToPredictionGraph || predictorIndices.length == 1) ? ", PlotStyle -> {Red, Opacity[0.5]}" : ", PlotStyle -> {Red}")
					+ ", PlotMarkers->{Automatic}"
					+ axesLabels
					+ ((graphType == GraphType.ExampleNumberToPredictionGraph || predictorIndices.length == 1) ? twoDimPredictionsPlotRange : threeDimPlotRange)
					+ ", ImageSize -> Large"
					+ ", PlotRange -> All"
					+ "]\n\n");
			
			bw.write(trainingPredictionCurveBaseName + "Plot = " + plotCommand + "[{" + trainingPredictionCurveBaseName + "Data}"
					+ ", PlotLegends -> {\"Training\"}"
					+ ", PlotStyle -> {{Green, Opacity[0.5]}}"
					+ ", PlotMarkers->{Automatic}"
					+ axesLabels
					+ ((graphType == GraphType.ExampleNumberToPredictionGraph || predictorIndices.length == 1) ? twoDimPredictionsPlotRange : threeDimPlotRange)
					+ ", ImageSize -> Large"
					+ ", PlotRange -> All"
					+ "]\n\n");
			
			bw.write(testPredictionCurveBaseName + "Plot = " + plotCommand + "[{" + testPredictionCurveBaseName + "Data}"
					+ ", PlotLegends -> {\"Test\"}"
					+ ", PlotStyle -> {{Blue, Opacity[0.5]}}"
					+ ", PlotMarkers->{Automatic}"
					+ axesLabels
					+ ((graphType == GraphType.ExampleNumberToPredictionGraph || predictorIndices.length == 1) ? twoDimPredictionsPlotRange : threeDimPlotRange)
					+ ", ImageSize -> Large"
					+ ", PlotRange -> All"
					+ "]\n\n");
			
			bw.write(trainingResidualCurveBaseName + "Plot = " + plotCommand + "[{" + trainingResidualCurveBaseName + "Data}"
					+ ", PlotLegends -> {\"Training\"}"
					+ ", PlotStyle -> {{Green, Opacity[0.5]}}"
					+ ", PlotMarkers->{Automatic}"
					+ axesLabels
					+ ((graphType == GraphType.ExampleNumberToPredictionGraph || predictorIndices.length == 1) ? twoDimResidualsPlotRange : threeDimPlotRange)
					+ ", ImageSize -> Large"
					+ ", PlotRange -> All"
					+ "]\n\n");
			
			bw.write(testResidualCurveBaseName + "Plot = " + plotCommand + "[{" + testResidualCurveBaseName + "Data}"
					+ ", PlotLegends -> {\"Test\"}"
					+ ", PlotStyle -> {{Blue, Opacity[0.5]}}"
					+ ", PlotMarkers->{Automatic}"
					+ axesLabels
					+ ((graphType == GraphType.ExampleNumberToPredictionGraph || predictorIndices.length == 1) ? twoDimResidualsPlotRange : threeDimPlotRange)
					+ ", ImageSize -> Large"
					+ ", PlotRange -> All"
					+ "]\n\n");

			bw.write("allPredictionCurves = Show[" + responseCurveBaseName + "Plot, " + trainingPredictionCurveBaseName + "Plot, " + testPredictionCurveBaseName + "Plot , PlotRange -> All]\n\n");
			bw.write("targetAndTrainingPredictionCurves = Show[" + responseCurveBaseName + "Plot, " + trainingPredictionCurveBaseName + "Plot, PlotRange -> All]\n\n");
			bw.write("targetAndTestPredictionCurves = Show[" + responseCurveBaseName + "Plot, " + testPredictionCurveBaseName + "Plot, PlotRange -> All]\n\n");
			bw.write("allResidualCurves = Show[" + trainingResidualCurveBaseName + "Plot, " + testResidualCurveBaseName + "Plot, PlotRange -> All]\n\n");
		}
		
		private void printSaveToFileCode(BufferedWriter bw) throws IOException {
			bw.append("fileName = \"" + (graphsDirectory + responseCurveBaseName) + "\"\n");
			bw.append("Export[fileName <> \".png\", " + (responseCurveBaseName + "Plot") + ", ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + trainingPredictionCurveBaseName) + "\"\n");
			bw.append("Export[fileName <> \".png\", " + (trainingPredictionCurveBaseName + "Plot") + ", ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + testPredictionCurveBaseName) + "\"\n");
			bw.append("Export[fileName <> \".png\", " + (testPredictionCurveBaseName + "Plot") + ", ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + "allPredictionCurves") + "\"\n");
			bw.append("Export[fileName <> \".png\", allPredictionCurves, ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + "targetAndTrainingPredictionCurves") + "\"\n");
			bw.append("Export[fileName <> \".png\", targetAndTrainingPredictionCurves, ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + "targetAndTestPredictionCurves") + "\"\n");
			bw.append("Export[fileName <> \".png\", targetAndTestPredictionCurves, ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + trainingResidualCurveBaseName) + "\"\n");
			bw.append("Export[fileName <> \".png\", " + (trainingResidualCurveBaseName + "Plot") + ", ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + testResidualCurveBaseName) + "\"\n");
			bw.append("Export[fileName <> \".png\", " + (testResidualCurveBaseName + "Plot") + ", ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + "allResidualCurves") + "\"\n");
			bw.append("Export[fileName <> \".png\", allResidualCurves, ImageResolution -> 300]\n\n");
		}
		
		private void printLatexCode(BufferedWriter bw) throws IOException {
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + responseCurveBaseName) + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption(responseCurveBaseName) + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId(responseCurveBaseName) + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + trainingPredictionCurveBaseName) + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption(trainingPredictionCurveBaseName) + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId(trainingPredictionCurveBaseName) + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + testPredictionCurveBaseName) + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption(testPredictionCurveBaseName) + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId(testPredictionCurveBaseName) + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + "allPredictionCurves") + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption("allPredictionCurves") + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId("allPredictionCurves") + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + "targetAndTrainingPredictionCurves") + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption("targetAndTrainingPredictionCurves") + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId("targetAndTrainingPredictionCurves") + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + "targetAndTestPredictionCurves") + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption("targetAndTestPredictionCurves") + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId("targetAndTestPredictionCurves") + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + trainingResidualCurveBaseName) + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption(trainingResidualCurveBaseName) + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId(trainingResidualCurveBaseName) + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + testResidualCurveBaseName) + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption(testResidualCurveBaseName) + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId(testResidualCurveBaseName) + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + "allResidualCurves") + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption("allResidualCurves") + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId("allResidualCurves") + "}\n");
			bw.append("\\end{figure}\n\n");
		}
		
		private String getLatexFigureId(String curveName) {
			if (graphType == GraphType.ExampleNumberToPredictionGraph) {
				return dataset.parameters.minimalName + graphType.name() + curveName;
			} else {
				return dataset.parameters.minimalName + predictorNamesSubDirectory + curveName;
			}
		}
		
		private String getLatexCaption(String curveName) {
			if (graphType == GraphType.ExampleNumberToPredictionGraph) {
				return dataset.parameters.fullName + graphType.name() + curveName;
			} else {
				return dataset.parameters.fullName + " " + predictorNamesSubDirectory + " " + curveName;
			}
		}

		private TreeSet<Point> getPairWisePredictorGraphPoints() {
			HashMap<UniqueXYPointKey, Point> uniqueXYPointKeyToAvgZValueMap = new HashMap<>();
			Attribute[][] instances = dataset.getTrainingInstances();
			
			for (int i = 0; i < numberOfExamples; i++) {
				Attribute[] instance = instances[i];
				UniqueXYPointKey key = new UniqueXYPointKey(instance, predictorIndices);
				
				PairwisePredictionGraphPoint avg = (PairwisePredictionGraphPoint)uniqueXYPointKeyToAvgZValueMap.get(key);
				if (avg == null) {
					avg = new PairwisePredictionGraphPoint(key);
					uniqueXYPointKeyToAvgZValueMap.put(key, avg);
				}
				avg.response.addData(targetResponses[i]);
				if (trainingDataCount[i] > 0) {
					avg.predictionAsTrainingData.addData(trainingDataPrediction[i]);
				}
				if (testDataCount[i] > 0) {
					avg.predictionAsTestData.addData(testDataPrediction[i]);
				}
			}
			
			return new TreeSet<Point>(uniqueXYPointKeyToAvgZValueMap.values());
		}
		
		private TreeSet<Point> getExampleNumberPredictionGraphPoints() {
			TreeSet<Point> points = new TreeSet<Point>();
			for (int i = 0; i < numberOfExamples; i++) {
				points.add(new ExampleNumberPredictionGraphPoint(
						i, 
						targetResponses[i], 
						(trainingDataCount[i] == 0) ? null : trainingDataPrediction[i], 
						(testDataCount[i] == 0) ? null : testDataPrediction[i])
				);
			}
			return points;
		}
		
	}
	
	private static abstract class Point implements Comparable<Point> {
		public abstract String getResponseCurveEntry();

		public abstract String getTrainingDataPredictionCurveEntry();
		
		public abstract String getTestDataPredictionCurveEntry();
		
		public abstract String getTrainingDataResidualCurveEntry();

		public abstract String getTestDataResidualCurveEntry();
		
		public abstract double getResponseValue();
		public abstract double getTrainingDataPredictionValue();
		public abstract double getTestDataPredictionValue();
		public abstract double getTrainingDataResidualValue();
		public abstract double getTestDataResidualValue();
	}
	
	private static class PairwisePredictionGraphPoint extends Point implements Comparable<Point> {
		public SumCountAverage response= new SumCountAverage();
		// Count of these SumCountAvergaes will be 0 if no tests used any examples with this key as training or test data respectively
		public SumCountAverage predictionAsTrainingData = new SumCountAverage();
		public SumCountAverage predictionAsTestData = new SumCountAverage();
		public UniqueXYPointKey key;
		public PairwisePredictionGraphPoint(UniqueXYPointKey key) {
			this.key = key;
		}

		@Override
		public int compareTo(Point that) {
			if (getClass() != that.getClass()) {
				throw new IllegalStateException();
			}
			return this.key.compareTo(((PairwisePredictionGraphPoint)that).key);
		}
		
		public String getResponseCurveEntry() {
			return String.format("{ %s, %f }", key.getCommaSeparatedListOfXYValues(), response.getMean());
		}
		
		public String getTrainingDataPredictionCurveEntry() {
			if (predictionAsTrainingData.getCount() == 0) {
				return null;
			}
			return String.format("{ %s, %f }", key.getCommaSeparatedListOfXYValues(), predictionAsTrainingData.getMean());
		}
		
		public String getTestDataPredictionCurveEntry() {
			if (predictionAsTestData.getCount() == 0) {
				return null;
			}
			return String.format("{ %s, %f }", key.getCommaSeparatedListOfXYValues(), predictionAsTestData.getMean());
		}
		
		@Override
		public String getTrainingDataResidualCurveEntry() {
			if (predictionAsTrainingData.getCount() == 0) {
				return null;
			}
			return String.format("{ %s, %f }", key.getCommaSeparatedListOfXYValues(), response.getMean() - predictionAsTrainingData.getMean());
		}

		@Override
		public String getTestDataResidualCurveEntry() {
			if (predictionAsTrainingData.getCount() == 0) {
				return null;
			}
			return String.format("{ %s, %f }", key.getCommaSeparatedListOfXYValues(), response.getMean() - predictionAsTestData.getMean());
		}

		@Override
		public double getResponseValue() {
			return response.getMean();
		}

		@Override
		public double getTrainingDataPredictionValue() {
			return predictionAsTrainingData.getMean();
		}

		@Override
		public double getTestDataPredictionValue() {
			return predictionAsTestData.getMean();
		}

		@Override
		public double getTrainingDataResidualValue() {
			return response.getMean() - predictionAsTrainingData.getMean();
		}

		@Override
		public double getTestDataResidualValue() {
			return response.getMean() - predictionAsTestData.getMean();
		}
	}
	
	private class ExampleNumberPredictionGraphPoint extends Point implements Comparable<Point> {
		public int exampleNumber;
		public Double response;
		public Double predictionAsTrainingData;
		public Double predictionAsTestData;
		
		/**
		 * 
		 * @param exampleNumber
		 * @param response
		 * @param predictionAsTrainingData	Null if no tests used this example as training data
		 * @param predictionAsTestData	Null if no tests used this example as test data
		 */
		public ExampleNumberPredictionGraphPoint(int exampleNumber, Double response, Double predictionAsTrainingData, Double predictionAsTestData) {
			this.exampleNumber = exampleNumber;
			this.response = response;
			this.predictionAsTrainingData = predictionAsTrainingData;
			this.predictionAsTestData = predictionAsTestData;
		}

		@Override
		public int compareTo(Point that) {
			if (getClass() != that.getClass()) {
				throw new IllegalStateException();
			}
			return Integer.compare(this.exampleNumber, ((ExampleNumberPredictionGraphPoint)that).exampleNumber);
			//return Double.compare(this.response, ((ExampleNumberPredictionGraphPoint)that).response);
		}
		
		public String getResponseCurveEntry() {
			return String.format("{ %d, %f }", exampleNumber, response);
		}
		
		public String getTrainingDataPredictionCurveEntry() {
			if (predictionAsTrainingData == null) {
				return null;
			}
			return String.format("{ %d, %f }", exampleNumber, predictionAsTrainingData);
		}
		
		public String getTestDataPredictionCurveEntry() {
			if (predictionAsTestData == null) {
				return null;
			}
			return String.format("{ %d, %f }", exampleNumber, predictionAsTestData);
		}
		
		@Override
		public String getTrainingDataResidualCurveEntry() {
			if (predictionAsTrainingData == null) {
				return null;
			}
			return String.format("{ %d, %f }", exampleNumber, response - predictionAsTrainingData);
		}

		@Override
		public String getTestDataResidualCurveEntry() {
			if (predictionAsTestData == null) {
				return null;
			}
			return String.format("{ %d, %f }", exampleNumber, response - predictionAsTestData);
		}

		@Override
		public double getResponseValue() {
			return response;
		}

		@Override
		public double getTrainingDataPredictionValue() {
			return predictionAsTrainingData;
		}

		@Override
		public double getTestDataPredictionValue() {
			return predictionAsTestData;
		}
		
		@Override
		public double getTrainingDataResidualValue() {
			return response - predictionAsTrainingData;
		}

		@Override
		public double getTestDataResidualValue() {
			return response - predictionAsTestData;
		}
	}
	
	private static class UniqueXYPointKey implements Comparable<UniqueXYPointKey> {
		public Attribute[] XYvalues;
		public UniqueXYPointKey(Attribute[] instance, int[] predictorIndices) {
			if (predictorIndices.length < 1 || predictorIndices.length > 2) {
				throw new IllegalArgumentException("Only 2D and 3D graphs are defined");
			}
			
			XYvalues = new Attribute[predictorIndices.length];
			for (int i = 0; i < XYvalues.length; i++) {
				XYvalues[i] = instance[predictorIndices[i]];
			}
		}
		
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + Arrays.hashCode(XYvalues);
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			UniqueXYPointKey other = (UniqueXYPointKey) obj;
			if (!Arrays.equals(XYvalues, other.XYvalues))
				return false;
			return true;
		}
		
		@Override
		public int compareTo(UniqueXYPointKey that) {
			int comp = XYvalues[0].compareTo(that.XYvalues[0]);
			if (comp == 0 && XYvalues.length > 1) {
				comp = XYvalues[1].compareTo(that.XYvalues[1]);
			}
			return comp;
		}
		
		public String getCommaSeparatedListOfXYValues() {
			if (XYvalues.length == 1) {
				return XYvalues[0].toString();
			}
			if (XYvalues.length == 2) {
				return XYvalues[0].toString() + ", " + XYvalues[1].toString(); 
			}
			throw new IllegalStateException();
		}
	}
}
