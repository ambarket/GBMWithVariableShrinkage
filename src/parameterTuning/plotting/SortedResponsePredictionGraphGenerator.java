package parameterTuning.plotting;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.concurrent.Callable;

import dataset.Dataset;
import gbm.GbmParameters;
import parameterTuning.ParameterTuningParameters;
import utilities.CommandLineExecutor;
import utilities.MaxAndMin;
import utilities.SimpleHostLock;
import utilities.StopWatch;

public class SortedResponsePredictionGraphGenerator implements Callable<Void> {
	Dataset dataset;
	GbmParameters parameters;
	String runDataFullDirectory;
	ParameterTuningParameters tuningParameters;
	int submissionNumber;
	StopWatch globalTimer;
	String[][] predictorNamesSets;
	
	int numberOfExamples;
	
	int[] trainingDataCount;
	double[] trainingDataPrediction;
	double[] trainingDataResidual;
	double[] trainingDataAvgLearningRate;
	
	int[] testDataCount;
	double[] testDataPrediction;
	double[] testDataResidual;
	double[] testDataAvgLearningRate;
	
	double[] targetResponses;
	
	String allGraphsDirectory;
	public SortedResponsePredictionGraphGenerator(Dataset dataset, GbmParameters parameters, String runDataFullDirectory, ParameterTuningParameters tuningParameters, int submissionNumber, StopWatch globalTimer) {
		this.dataset = dataset;
		this.parameters = parameters;
		this.runDataFullDirectory = runDataFullDirectory;
		this.tuningParameters = tuningParameters;
		this.submissionNumber = submissionNumber;
		this.globalTimer = globalTimer;
		

		
		numberOfExamples = dataset.getNumberOfTotalNumberOfExamples();
		
		trainingDataCount = new int[numberOfExamples];
		trainingDataPrediction = new double[numberOfExamples];
		trainingDataResidual = new double[numberOfExamples];
		trainingDataAvgLearningRate = new double[numberOfExamples];
		
		testDataCount = new int[numberOfExamples];
		testDataPrediction = new double[numberOfExamples];
		testDataResidual = new double[numberOfExamples];
		testDataAvgLearningRate = new double[numberOfExamples];
		
		targetResponses = new double[numberOfExamples];
		
		this.allGraphsDirectory = runDataFullDirectory + parameters.getRunDataSubDirectory(tuningParameters.runFileType) + "SortedPerExampleRunDataGraphs/";
	}
	
	public Void call() {
		StopWatch timer = new StopWatch().start();
		String locksDir = tuningParameters.locksDirectory + dataset.parameters.minimalName + "/SortedPerExampleRunDataGraphs/" + parameters.getRunDataSubDirectory(tuningParameters.runFileType);
		new File(locksDir).mkdirs();
		if (SimpleHostLock.checkDoneLock(locksDir + "predictionGraphs--doneLock.txt")) {
			printSuccessMessage("Graphs already generated by another host or previous run", timer);
			return null;
		}
		if (!SimpleHostLock.checkAndClaimHostLock(locksDir + "predictionGraphs--hostLock.txt")) {
			System.out.println(StopWatch.getDateTimeStamp() + String.format("[%s] Another host claimed prediction graphs for %s (%d out of %d) in %s. Have been running for %s total.", 
					dataset.parameters.minimalName,parameters.getRunDataSubDirectory(tuningParameters.runFileType), submissionNumber, tuningParameters.totalNumberOfTests, timer.getTimeInMostAppropriateUnit(), globalTimer.getTimeInMostAppropriateUnit()));
			return null;
		}
		
		String runDataFilePath = runDataFullDirectory + parameters.getRunDataSubDirectory(tuningParameters.runFileType) + parameters.getFileNamePrefix(tuningParameters.runFileType)  + "--averagePerExampleRunData.txt";
		try {
			BufferedReader br = new BufferedReader(new FileReader(runDataFilePath));
			br.readLine(); // skip header
			// read in error data 
			String line = null;
			int i = 0;
			while ((line = br.readLine()) != null) {
				String[] components = line.split("\t");

				if (Integer.parseInt(components[0]) != i) {
					throw new IllegalStateException();
				}
				
				targetResponses[i] = Double.parseDouble(components[1]);
				trainingDataCount[i] = Integer.parseInt(components[2]);
				trainingDataPrediction[i] = Double.parseDouble(components[3]);
				trainingDataResidual[i] = Double.parseDouble(components[4]);
				trainingDataAvgLearningRate[i] = Double.parseDouble(components[5]);
				testDataCount[i] = Integer.parseInt(components[6]);
				testDataPrediction[i] = Double.parseDouble(components[7]);
				testDataResidual[i] = Double.parseDouble(components[8]);
				testDataAvgLearningRate[i] = Double.parseDouble(components[9]);

				i++;
			}
			br.close();
		} catch (IOException e) {
			System.err.println(StopWatch.getDateTimeStamp());
			e.printStackTrace();
			printFailureMessage("Reading of per example run data failed, not writing done lock!", timer);
			return null;
		}
		

		boolean success = false;
		Graph exampleNumGraph = new Graph(GraphType.ExampleNumberToPredictionGraph);
		success = exampleNumGraph.generateMathematicaScriptAndLatexCode();
		if (!success) {
			printFailureMessage("Generation of Sorted Response Prediction graphs failed, not writing done lock!", timer); 
			return null;
		} 
		success = CommandLineExecutor.executeMathematicaScript(exampleNumGraph.graphsDirectory, exampleNumGraph.mathematicaScriptFileName);
		
		if (!success) {
			printFailureMessage("Execution of Sorted Response Prediction graphs mathematica script failed, not writing done lock!", timer); 
			return null;
		}

		printSuccessMessage("Sorted Response Prediction graphs successfully generated and executed by this run.", timer);
		SimpleHostLock.writeDoneLock(locksDir + "predictionGraphs--doneLock.txt");
		return null;
		
	}
	
	private void printFailureMessage(String reason, StopWatch timer) {
		System.out.println(StopWatch.getDateTimeStamp() + String.format("[%s] " + reason + "\n\t Failed to generate per example graphs for %s (%d out of %d) in %s. Have been running for %s total.\n\t\t%s", 
				dataset.parameters.minimalName,parameters.getRunDataSubDirectory(tuningParameters.runFileType), submissionNumber, tuningParameters.totalNumberOfTests, timer.getTimeInMostAppropriateUnit(), globalTimer.getTimeInMostAppropriateUnit(), allGraphsDirectory));
	}
	
	private void printSuccessMessage(String reason, StopWatch timer) {
		System.out.println(StopWatch.getDateTimeStamp() + String.format("[%s] " + reason + "\n\t Successfully finished generating and executing per example graphs for %s (%d out of %d) in %s. Have been running for %s total.\n\t\t%s", 
				dataset.parameters.minimalName,parameters.getRunDataSubDirectory(tuningParameters.runFileType), submissionNumber, tuningParameters.totalNumberOfTests, timer.getTimeInMostAppropriateUnit(), globalTimer.getTimeInMostAppropriateUnit(), allGraphsDirectory));
	}
	
	public enum GraphType {ExampleNumberToPredictionGraph, PredictorsToPredictionGraph};
	private class Graph {
		
		GraphType graphType;
		
		String responseCurveBaseName = "targetResponses";
		String trainingPredictionCurveBaseName = "TrainingPredictions";
		String testPredictionCurveBaseName = "TestPredictions";
		
		String trainingResidualCurveBaseName = "TrainingResiduals";
		String testResidualCurveBaseName = "TestResiduals";
		
		String mathematicaScriptFileName = "MathScript.m";
		String latexCodeFileName = "latexCode.txt";
		
		
		String graphsDirectory;
		
		int[] predictorIndices;
		
		String predictorNamesSubDirectory;
		
		String axesLabels;
		
		public Graph(GraphType graphType) {
			this.graphType = graphType;
			
			if (graphType == GraphType.ExampleNumberToPredictionGraph) {
				graphsDirectory = allGraphsDirectory + "ExampleNumberToPredictionGraphs/";
			} else {
				throw new IllegalArgumentException();
			}
			
			axesLabels = ", AxesLabel->\"" + dataset.getResponseName() + "\"";
		}
		
		public boolean generateMathematicaScriptAndLatexCode() {
			new File(graphsDirectory).mkdirs();
			try {
				BufferedWriter mathScript = new BufferedWriter(new PrintWriter(graphsDirectory + mathematicaScriptFileName));
				BufferedWriter latexCode = new BufferedWriter(new PrintWriter(graphsDirectory + latexCodeFileName));
		
				if (dataset.parameters.minimalName.equals("bikeSharingDay")) {
					MaxAndMin[] plotRanges = printDataLists(mathScript, false);
					printPlotCode(mathScript, plotRanges, false);
				} else {
					MaxAndMin[] plotRanges = printDataLists(mathScript, true);
					printPlotCode(mathScript, plotRanges, true);
				}
				printSaveToFileCode(mathScript);
				mathScript.flush();
				mathScript.close();
				
				printLatexCode(latexCode);
				latexCode.flush();
				latexCode.close();
				
				return true;
			} catch (IOException e) {
				System.err.println(StopWatch.getDateTimeStamp());
				e.printStackTrace();
				return false;
			}
		}
		
		private MaxAndMin[] printDataLists(BufferedWriter bw, boolean sorted) throws IOException {
			ArrayList<Point> pointsInOrderOfTargetResponse = null;
			if (graphType == GraphType.ExampleNumberToPredictionGraph) {
				pointsInOrderOfTargetResponse = getExampleNumberPredictionGraphPoints();
			} else if (graphType == GraphType.PredictorsToPredictionGraph) {
				throw new IllegalArgumentException();
			}
			
			StringBuilder responseCurve = new StringBuilder();
			StringBuilder trainingPredictionCurve = new StringBuilder();
			StringBuilder testPredictionCurve = new StringBuilder();
			StringBuilder trainingResidualCurve = new StringBuilder();
			StringBuilder testResidualCurve = new StringBuilder();
			MaxAndMin[] plotRanges = new MaxAndMin[] {new MaxAndMin(), new MaxAndMin()}; // 0 - predication/response graph 1 - residuals graph
			for (int i = 0; i < pointsInOrderOfTargetResponse.size(); i++) {
				Point p = pointsInOrderOfTargetResponse.get(i);
				
				String trainingDataEntry, testDataEntry, trainingResidualEntry, testResidualEntry, responseCurveEntry;
				if (sorted) {
					responseCurveEntry = p.getResponseCurveEntry(i);
					trainingDataEntry = p.getTrainingDataPredictionCurveEntry(i);
					testDataEntry = p.getTestDataPredictionCurveEntry(i);
					trainingResidualEntry = p.getTrainingDataResidualCurveEntry(i);
					testResidualEntry = p.getTestDataResidualCurveEntry(i);
				} else {
					responseCurveEntry = p.getResponseCurveEntry();
					trainingDataEntry = p.getTrainingDataPredictionCurveEntry();
					testDataEntry = p.getTestDataPredictionCurveEntry();
					trainingResidualEntry = p.getTrainingDataResidualCurveEntry();
					testResidualEntry = p.getTestDataResidualCurveEntry();
				}
				
				if (responseCurveEntry != null) {
					if (responseCurve.length() != 0) {
						responseCurve.append(", ");
					}  else {
						responseCurve.append(responseCurveBaseName + "Data = {");
					}
					responseCurve.append(responseCurveEntry);
					plotRanges[0].updateMaxAndMinIfNecessary(p.getResponseValue());
				} else {
					throw new IllegalStateException("Makes no sense for response entry to be null.");
				}
				
				// Only graph training/test data entry if at least one of the averaged run data files used an examples
				//	as training and test data respectively.
				if (trainingDataEntry != null) {
					if (trainingPredictionCurve.length() != 0) {
						trainingPredictionCurve.append(", ");
					}  else {
						trainingPredictionCurve.append(trainingPredictionCurveBaseName + "Data = {");
					}
					trainingPredictionCurve.append(trainingDataEntry);
					plotRanges[0].updateMaxAndMinIfNecessary(p.getTrainingDataPredictionValue());
				}
				if (testDataEntry != null) {
					if (testPredictionCurve.length() != 0) {
						testPredictionCurve.append(", ");
					}  else {
						testPredictionCurve.append(testPredictionCurveBaseName + "Data = {");
					}
					testPredictionCurve.append(testDataEntry);
					plotRanges[0].updateMaxAndMinIfNecessary(p.getTestDataPredictionValue());
				}
				if (trainingResidualEntry != null) {
					if (trainingResidualCurve.length() != 0) {
						trainingResidualCurve.append(", ");
					}  else {
						trainingResidualCurve.append(trainingResidualCurveBaseName + "Data = {");
					}
					trainingResidualCurve.append(trainingResidualEntry);
					plotRanges[1].updateMaxAndMinIfNecessary(p.getTrainingDataResidualValue());
				}
				if (testResidualEntry != null) {
					if (testResidualCurve.length() != 0) {
						testResidualCurve.append(", ");
					}  else {
						testResidualCurve.append(testResidualCurveBaseName + "Data = {");
					}
					testResidualCurve.append(testResidualEntry);
					plotRanges[1].updateMaxAndMinIfNecessary(p.getTestDataResidualValue());
				}
			}
			responseCurve.append("}\n\n");
			trainingPredictionCurve.append("}\n\n");
			testPredictionCurve.append("}\n\n");
			trainingResidualCurve.append("}\n\n");
			testResidualCurve.append("}\n\n");
			
			bw.write(responseCurve.toString());
			bw.write(trainingPredictionCurve.toString());
			bw.write(testPredictionCurve.toString());
			bw.write(trainingResidualCurve.toString());
			bw.write(testResidualCurve.toString());
			return plotRanges;
		}
		
		private void printPlotCode(BufferedWriter bw, MaxAndMin[] plotRanges, boolean sorted) throws IOException {
			String plotCommand = null;
			if (graphType == GraphType.ExampleNumberToPredictionGraph || predictorIndices.length == 1) {
				plotCommand = "ListPlot";
			} else {
				plotCommand = "ListPlot3D";
			}
			
			String predictionsPlotRange = "{" + plotRanges[0].min + ", " + plotRanges[0].max + "}";
			String residualPlotRange = "{" + plotRanges[1].min + ", " + plotRanges[1].max + "}";
			String automaticPlotRange = "Automatic";
			String twoDimPredictionsPlotRange = ", PlotRange -> {" + automaticPlotRange + ", " + predictionsPlotRange + "}";
			String twoDimResidualsPlotRange = ", PlotRange -> {" + automaticPlotRange + ", " + residualPlotRange + "}";
			String threeDimPlotRange = ", PlotRange -> {" + automaticPlotRange + ", " + automaticPlotRange + ", " + predictionsPlotRange + "}";

			String plotRangePadding = ", PlotRangePadding->{{Scaled[0.03],Scaled[0.03]}, {Scaled[0.03], Scaled[0.03]}}";
			bw.write(responseCurveBaseName + "Plot = " + plotCommand + "[{" + responseCurveBaseName + "Data}"
					//+ ", PlotLegends -> {\"Target\"}"
					+ ((graphType == GraphType.ExampleNumberToPredictionGraph || predictorIndices.length == 1) ? ", PlotStyle -> {Red, Opacity[0.5]}" : ", PlotStyle -> {Red}")
					+ ", PlotMarkers->{Automatic}"
					+ ((graphType == GraphType.ExampleNumberToPredictionGraph || predictorIndices.length == 1) ? twoDimPredictionsPlotRange : threeDimPlotRange)
					+ ", ImageSize -> Large"
					+ ", PlotRange -> All"
					+ getFrame(true, sorted)
					+ plotRangePadding
					+ "]\n\n");
			
			bw.write(trainingPredictionCurveBaseName + "Plot = " + plotCommand + "[{" + trainingPredictionCurveBaseName + "Data}"
					//+ ", PlotLegends -> {\"Training\"}"
					+ ", PlotStyle -> {{Green, Opacity[0.5]}}"
					+ ", PlotMarkers->{Automatic}"
					+ ((graphType == GraphType.ExampleNumberToPredictionGraph || predictorIndices.length == 1) ? twoDimPredictionsPlotRange : threeDimPlotRange)
					+ ", ImageSize -> Large"
					+ ", PlotRange -> All"
					+ getFrame(true, sorted)
					+ plotRangePadding
					+ "]\n\n");
			
			bw.write(testPredictionCurveBaseName + "Plot = " + plotCommand + "[{" + testPredictionCurveBaseName + "Data}"
					//+ ", PlotLegends -> {\"Test\"}"
					+ ", PlotStyle -> {{Blue, Opacity[0.5]}}"
					+ ", PlotMarkers->{Automatic}"
					+ ((graphType == GraphType.ExampleNumberToPredictionGraph || predictorIndices.length == 1) ? twoDimPredictionsPlotRange : threeDimPlotRange)
					+ ", ImageSize -> Large"
					+ ", PlotRange -> All"
					+ getFrame(true, sorted)
					+ plotRangePadding
					+ "]\n\n");
			
			bw.write(trainingResidualCurveBaseName + "Plot = " + plotCommand + "[{" + trainingResidualCurveBaseName + "Data}"
					//+ ", PlotLegends -> {\"Training\"}"
					+ ", PlotStyle -> {{Green, Opacity[0.5]}}"
					+ ", PlotMarkers->{Automatic}"
					+ ((graphType == GraphType.ExampleNumberToPredictionGraph || predictorIndices.length == 1) ? twoDimResidualsPlotRange : threeDimPlotRange)
					+ ", ImageSize -> Large"
					+ ", PlotRange -> All"
					+ getFrame(false, sorted)
					+ plotRangePadding
					+ "]\n\n");
			
			bw.write(testResidualCurveBaseName + "Plot = " + plotCommand + "[{" + testResidualCurveBaseName + "Data}"
					//+ ", PlotLegends -> {\"Test\"}"
					+ ", PlotStyle -> {{Blue, Opacity[0.5]}}"
					+ ", PlotMarkers->{Automatic}"
					+ ((graphType == GraphType.ExampleNumberToPredictionGraph || predictorIndices.length == 1) ? twoDimResidualsPlotRange : threeDimPlotRange)
					+ ", ImageSize -> Large"
					+ ", PlotRange -> All"
					+ getFrame(false, sorted)
					+ plotRangePadding
					+ "]\n\n");

			bw.write("allPredictionCurves = Show[" + responseCurveBaseName + "Plot, " + trainingPredictionCurveBaseName + "Plot, " + testPredictionCurveBaseName + "Plot , PlotRange -> All]\n\n");
			bw.write("targetAndTrainingPredictionCurves = Show[" + responseCurveBaseName + "Plot, " + trainingPredictionCurveBaseName + "Plot, PlotRange -> All]\n\n");
			bw.write("targetAndTestPredictionCurves = Show[" + responseCurveBaseName + "Plot, " + testPredictionCurveBaseName + "Plot, PlotRange -> All]\n\n");
			bw.write("allResidualCurves = Show[" + trainingResidualCurveBaseName + "Plot, " + testResidualCurveBaseName + "Plot, PlotRange -> All]\n\n");
		}
		
		private String getFrame(boolean predictionsOrResiduals, boolean sorted) {
			StringBuffer buffer = new StringBuffer();
			buffer.append(", Axes->False ");
			buffer.append(", Frame->True");
			buffer.append(", FrameStyle->Black");
			buffer.append(", FrameTicksStyle->Black");
			buffer.append(", LabelStyle->{Black, 12}");
			buffer.append(", FrameLabel->{");
			if (sorted) {
				buffer.append("\"Examples (Sorted by Target Response)\", ");
			} else {
				buffer.append("\"Examples (Sorted by Rental Date)\", ");
			}
			if (predictionsOrResiduals) {
				buffer.append("\"Response\"");
			} else {
				buffer.append("\"Residual\"");
			}
			buffer.append("}");
			buffer.append(", FrameTicks->{{Automatic, None}, {Automatic, None}} ");
			return buffer.toString();
		}
		
		
		private void printSaveToFileCode(BufferedWriter bw) throws IOException {
			bw.append("fileName = \"" + (graphsDirectory + responseCurveBaseName) + "\"\n");
			bw.append("Export[fileName <> \".png\", " + (responseCurveBaseName + "Plot") + ", ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + trainingPredictionCurveBaseName) + "\"\n");
			bw.append("Export[fileName <> \".png\", " + (trainingPredictionCurveBaseName + "Plot") + ", ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + testPredictionCurveBaseName) + "\"\n");
			bw.append("Export[fileName <> \".png\", " + (testPredictionCurveBaseName + "Plot") + ", ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + "allPredictionCurves") + "\"\n");
			bw.append("Export[fileName <> \".png\", allPredictionCurves, ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + "targetAndTrainingPredictionCurves") + "\"\n");
			bw.append("Export[fileName <> \".png\", targetAndTrainingPredictionCurves, ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + "targetAndTestPredictionCurves") + "\"\n");
			bw.append("Export[fileName <> \".png\", targetAndTestPredictionCurves, ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + trainingResidualCurveBaseName) + "\"\n");
			bw.append("Export[fileName <> \".png\", " + (trainingResidualCurveBaseName + "Plot") + ", ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + testResidualCurveBaseName) + "\"\n");
			bw.append("Export[fileName <> \".png\", " + (testResidualCurveBaseName + "Plot") + ", ImageResolution -> 300]\n\n");
			
			bw.append("fileName = \"" + (graphsDirectory + "allResidualCurves") + "\"\n");
			bw.append("Export[fileName <> \".png\", allResidualCurves, ImageResolution -> 300]\n\n");
		}
		
		private void printLatexCode(BufferedWriter bw) throws IOException {
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + responseCurveBaseName) + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption(responseCurveBaseName) + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId(responseCurveBaseName) + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + trainingPredictionCurveBaseName) + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption(trainingPredictionCurveBaseName) + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId(trainingPredictionCurveBaseName) + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + testPredictionCurveBaseName) + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption(testPredictionCurveBaseName) + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId(testPredictionCurveBaseName) + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + "allPredictionCurves") + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption("allPredictionCurves") + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId("allPredictionCurves") + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + "targetAndTrainingPredictionCurves") + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption("targetAndTrainingPredictionCurves") + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId("targetAndTrainingPredictionCurves") + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + "targetAndTestPredictionCurves") + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption("targetAndTestPredictionCurves") + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId("targetAndTestPredictionCurves") + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + trainingResidualCurveBaseName) + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption(trainingResidualCurveBaseName) + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId(trainingResidualCurveBaseName) + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + testResidualCurveBaseName) + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption(testResidualCurveBaseName) + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId(testResidualCurveBaseName) + "}\n");
			bw.append("\\end{figure}\n\n");
			
			bw.append("\\begin{figure}[!htb]\\centering\n");
			bw.append("\\includegraphics[width=1\\textwidth]{{" + (graphsDirectory + "allResidualCurves") + "}.png}\n");
			bw.append("\\caption{" + getLatexCaption("allResidualCurves") + "}\n");
			bw.append("\\label{fig:" + getLatexFigureId("allResidualCurves") + "}\n");
			bw.append("\\end{figure}\n\n");
		}
		
		private String getLatexFigureId(String curveName) {
			if (graphType == GraphType.ExampleNumberToPredictionGraph) {
				return dataset.parameters.minimalName + graphType.name() + curveName;
			} else {
				return dataset.parameters.minimalName + predictorNamesSubDirectory + curveName;
			}
		}
		
		private String getLatexCaption(String curveName) {
			if (graphType == GraphType.ExampleNumberToPredictionGraph) {
				return dataset.parameters.fullName + graphType.name() + curveName;
			} else {
				return dataset.parameters.fullName + " " + predictorNamesSubDirectory + " " + curveName;
			}
		}
		
		private ArrayList<Point> getExampleNumberPredictionGraphPoints() {
			ArrayList<Point> points = new ArrayList<Point>();
			int[] numericalResponsesSortedIndexMap =  dataset.getNumericalResponsesSortedIndexMap();
			for (int i = 0; i < numberOfExamples; i++) {
				int realIndex = numericalResponsesSortedIndexMap[i];
				points.add(new Point(
						realIndex, 
						targetResponses[realIndex], 
						(trainingDataCount[realIndex] == 0) ? null : trainingDataPrediction[realIndex], 
						(testDataCount[realIndex] == 0) ? null : testDataPrediction[realIndex])
				);
			}
			return points;
		}
		
	}
	
	private class Point{
		public int exampleNumber;
		public Double response;
		public Double predictionAsTrainingData;
		public Double predictionAsTestData;
		
		/**
		 * 
		 * @param exampleNumber
		 * @param response
		 * @param predictionAsTrainingData	Null if no tests used this example as training data
		 * @param predictionAsTestData	Null if no tests used this example as test data
		 */
		public Point(int exampleNumber, Double response, Double predictionAsTrainingData, Double predictionAsTestData) {
			this.exampleNumber = exampleNumber;
			this.response = response;
			this.predictionAsTrainingData = predictionAsTrainingData;
			this.predictionAsTestData = predictionAsTestData;
		}
		
		public String getResponseCurveEntry(int sortedExampleNumber) {
			return String.format("{ %d, %f }", sortedExampleNumber, response);
		}
		
		public String getTrainingDataPredictionCurveEntry(int sortedExampleNumber) {
			if (predictionAsTrainingData == null) {
				return null;
			}
			return String.format("{ %d, %f }", sortedExampleNumber, predictionAsTrainingData);
		}
		
		public String getTestDataPredictionCurveEntry(int sortedExampleNumber) {
			if (predictionAsTestData == null) {
				return null;
			}
			return String.format("{ %d, %f }", sortedExampleNumber, predictionAsTestData);
		}
		
		public String getTrainingDataResidualCurveEntry(int sortedExampleNumber) {
			if (predictionAsTrainingData == null) {
				return null;
			}
			return String.format("{ %d, %f }", sortedExampleNumber, response - predictionAsTrainingData);
		}

		public String getTestDataResidualCurveEntry(int sortedExampleNumber) {
			if (predictionAsTestData == null) {
				return null;
			}
			return String.format("{ %d, %f }", sortedExampleNumber, response - predictionAsTestData);
		}
		
		public String getResponseCurveEntry() {
			return String.format("{ %d, %f }", exampleNumber, response);
		}
		
		public String getTrainingDataPredictionCurveEntry() {
			if (predictionAsTrainingData == null) {
				return null;
			}
			return String.format("{ %d, %f }", exampleNumber, predictionAsTrainingData);
		}
		
		public String getTestDataPredictionCurveEntry() {
			if (predictionAsTestData == null) {
				return null;
			}
			return String.format("{ %d, %f }", exampleNumber, predictionAsTestData);
		}
		
		public String getTrainingDataResidualCurveEntry() {
			if (predictionAsTrainingData == null) {
				return null;
			}
			return String.format("{ %d, %f }", exampleNumber, response - predictionAsTrainingData);
		}

		public String getTestDataResidualCurveEntry() {
			if (predictionAsTestData == null) {
				return null;
			}
			return String.format("{ %d, %f }", exampleNumber, response - predictionAsTestData);
		}

		public double getResponseValue() {
			return response;
		}

		public double getTrainingDataPredictionValue() {
			return predictionAsTrainingData;
		}

		public double getTestDataPredictionValue() {
			return predictionAsTestData;
		}
		
		public double getTrainingDataResidualValue() {
			return response - predictionAsTrainingData;
		}

		public double getTestDataResidualValue() {
			return response - predictionAsTestData;
		}
	}

	public static void generateAndExecutePlotLegend(ParameterTuningParameters tuningParameters) {
		String file = tuningParameters.runDataProcessingDirectory + "/predictionAndResidualCurveLegend";
		
		try {
			BufferedWriter bw = new BufferedWriter(new PrintWriter(file + ".m"));
			bw.append("predictionAndResidualCurveLegend = LineLegend[{Red, Green, Blue}, {\"Target\", \"Training\", \"Test\"}]\n\n");
			bw.append("fileName = \"" + file  + "\"\n");
			bw.append("Export[fileName <> \".png\", predictionAndResidualCurveLegend, ImageResolution -> 300]\n\n");
			bw.flush();
			bw.close();
			CommandLineExecutor.executeMathematicaScript(tuningParameters.runDataProcessingDirectory, "predictionAndResidualCurveLegend.m");
		} catch (IOException e) {
			e.printStackTrace();
			System.exit(1);
		}

	}
}
